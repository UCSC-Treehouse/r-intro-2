[
["index.html", "Introduction to R, version 2 Introduction", " Introduction to R, version 2 Introduction These are course notes for the “Introduction to R” course given by Treehouse and the Vaske lab on Saturday November 16. The class will be held in 123 Sinsheimer on Saturday November 16. Schedule &amp; logistics 10:00am Welcome overview, Starting out in R, Data frames 12.30pm Lunch Break 1.30pm Plotting with ggplot2, Summarizing data, Thinking in R 3.00pm End Workshop R is a programming language used by many computational biologists. The purpose of this session is to give students who are interested in the Treehouse Undergraduate Bioinformatics Immersion (https://forms.gle/UpfxJgNnB1oe69qL7) a chance to gain some experience with R in a systematic way. NOTE: The building will be locked, but we will let you in at the back door (via Steinhart Way). The training session will require that you have a laptop and a web browser. We will have a lunch break, but lunch is not provided. During the workshop we will be using the RStudio Cloud to use R over the web: RStudio Cloud R is the language itself. RStudio provides a convenient environment in which to use R, either on your local computer or on a server. About this class The class was developed by the Monash Bioinformatics Platform for the Monash Data Fluency initiative. The teaching style is based on the style of The Carpentries. This is a new version of the course focussing on the modern Tidyverse set of packages. We believe this is currently the quickest route to being productive in R. Source code This book was created in R using the rmarkdown and bookdown packages! GitHub page Authors and copyright This course is developed for the Monash Bioinformatics Platform by Paul Harrison. This work is licensed under a CC BY-4: Creative Commons Attribution 4.0 International License. The attribution is “Monash Bioinformatics Platform” if copying or modifying these notes. "],
["starting-out-in-r.html", "1 Starting out in R 1.1 Variables 1.2 Saving code in an R script 1.3 Vectors 1.4 Types of vector 1.5 Indexing vectors 1.6 Sequences 1.7 Functions", " 1 Starting out in R R is both a programming language and an interactive environment for data exploration and statistics. Today we will be concentrating on R as an interactive environment. Working with R is primarily text-based. The basic mode of use for R is that the user types in a command in the R language and presses enter, and then R computes and displays the result. We will be working in RStudio. The easiest way to get started is to go to RStudio Cloud and create a new project. The main way of working with R is the console, where you enter commands and view results. RStudio surrounds this with various conveniences. In addition to the console panel, RStudio provides panels containing: A text editor, where R commands can be recorded for future reference. A history of commands that have been typed on the console. An “environment” pane with a list of variables, which contain values that R has been told to save from previous commands. A file manager. Help on the functions available in R. A panel to show plots. Open RStudio, click on the “Console” pane, type 1+1 and press enter. R displays the result of the calculation. In this document, we will show such an interaction with R as below. 1+1 ## [1] 2 + is called an operator. R has the operators you would expect for for basic mathematics: + - * / ^. It also has operators that do more obscure things. * has higher precedence than +. We can use brackets if necessary ( ). Try 1+2*3 and (1+2)*3. Spaces can be used to make code easier to read. We can compare with == &lt; &gt; &lt;= &gt;=. This produces a logical value, TRUE or FALSE. Note the double equals, ==, for equality comparison. 2 * 2 == 4 ## [1] TRUE There are also character strings such as &quot;string&quot;. A character string must be surrounded by either single or double quotes. 1.1 Variables A variable is a name for a value. We can create a new variable by assigning a value to it using &lt;-. width &lt;- 5 RStudio helpfully shows us the variable in the “Environment” pane. We can also print it by typing the name of the variable and hitting enter. In general, R will print to the console any object returned by a function or operation unless we assign it to a variable. width ## [1] 5 Examples of valid variables names: hello, subject_id, subject.ID, x42. Spaces aren’t ok inside variable names. Dots (.) are ok in R, unlike in many other languages. Numbers are ok, except as the first character. Punctuation is not allowed, with two exceptions: _ and .. We can do arithmetic with the variable: # Area of a square width * width ## [1] 25 and even save the result in another variable: # Save area in &quot;area&quot; variable area &lt;- width * width We can also change a variable’s value by assigning it a new value: width &lt;- 10 width ## [1] 10 area ## [1] 25 Notice that the value of area we calculated earlier hasn’t been updated. Assigning a new value to one variable does not change the values of other variables. This is different to a spreadsheet, but usual for programming languages. 1.2 Saving code in an R script Once we’ve created a few variables, it becomes important to record how they were calculated so we can reproduce them later. The usual workflow is to save your code in an R script (“.R file”). Go to “File/New File/R Script” to create a new R script. Code in your R script can be sent to the console by selecting it or placing the cursor on the correct line, and then pressing Control-Enter (Command-Enter on a Mac). Tip Add comments to code, using lines starting with the # character. This makes it easier for others to follow what the code is doing (and also for us the next time we come back to it). Challenge: using variables Re-write this calculation so that it doesn’t use variables: a &lt;- 4*20 b &lt;- 7 a+b Re-write this calcuation over multiple lines, using a variable: 2*2+2*2+2*2 1.3 Vectors A vector of numbers is a collection of numbers. “Vector” means different things in different fields (mathematics, geometry, biology), but in R it is a fancy name for a collection of numbers. We call the individual numbers elements of the vector. We can make vectors with c( ), for example c(1,2,3). c means “combine”. R is obsesssed with vectors, in R even single numbers are vectors of length one. Many things that can be done with a single number can also be done with a vector. For example arithmetic can be done on vectors as it can be on single numbers. myvec &lt;- c(10,20,30,40,50) myvec ## [1] 10 20 30 40 50 myvec + 1 ## [1] 11 21 31 41 51 myvec + myvec ## [1] 20 40 60 80 100 length(myvec) ## [1] 5 c(60, myvec) ## [1] 60 10 20 30 40 50 c(myvec, myvec) ## [1] 10 20 30 40 50 10 20 30 40 50 When we talk about the length of a vector, we are talking about the number of numbers in the vector. 1.4 Types of vector We will also encounter vectors of character strings, for example &quot;hello&quot; or c(&quot;hello&quot;,&quot;world&quot;). Also we will encounter “logical” vectors, which contain TRUE and FALSE values. R also has “factors”, which are categorical vectors, and behave much like character vectors (think the factors in an experiment). Challenge: mixing types Sometimes the best way to understand R is to try some examples and see what it does. What happens when you try to make a vector containing different types, using c( )? Make a vector with some numbers, and some words (eg. character strings like &quot;test&quot;, or &quot;hello&quot;). Why does the output show the numbers surrounded by quotes &quot; &quot; like character strings are? Because vectors can only contain one type of thing, R chooses a lowest common denominator type of vector, a type that can contain everything we are trying to put in it. A different language might stop with an error, but R tries to soldier on as best it can. A number can be represented as a character string, but a character string can not be represented as a number, so when we try to put both in the same vector R converts everything to a character string. 1.5 Indexing vectors Access elements of a vector with [ ], for example myvec[1] to get the first element. You can also assign to a specific element of a vector. myvec[1] ## [1] 10 myvec[2] ## [1] 20 myvec[2] &lt;- 5 myvec ## [1] 10 5 30 40 50 Can we use a vector to index another vector? Yes! myind &lt;- c(4,3,2) myvec[myind] ## [1] 40 30 5 We could equivalently have written: myvec[c(4,3,2)] ## [1] 40 30 5 Challenge: indexing We can create and index character vectors as well. A cafe is using R to create their menu. items &lt;- c(&quot;spam&quot;, &quot;eggs&quot;, &quot;beans&quot;, &quot;bacon&quot;, &quot;sausage&quot;) What does items[-3] produce? Based on what you find, use indexing to create a version of items without &quot;spam&quot;. Use indexing to create a vector containing spam, eggs, sausage, spam, and spam. Add a new item, “lobster”, to items. 1.6 Sequences Another way to create a vector is with :: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 This can be useful when combined with indexing: items[1:4] ## [1] &quot;spam&quot; &quot;eggs&quot; &quot;beans&quot; &quot;bacon&quot; 1.7 Functions Functions are the things that do all the work for us in R: calculate, manipulate data, read and write to files, produce plots. R has many built in functions and we will also be loading more specialized functions from “packages”. We’ve already seen several functions: c( ), length( ), and plot( ). Let’s now have a look at sum( ). sum(myvec) ## [1] 135 We called the function sum with the argument myvec, and it returned the value 135. We can get help on how to use sum with: ?sum Some functions take more than one argument. Let’s look at the function rep, which means “repeat”, and which can take a variety of different arguments. In the simplest case, it takes a value and the number of times to repeat that value. rep(42, 10) ## [1] 42 42 42 42 42 42 42 42 42 42 As with many functions in R—which is obsessed with vectors—the thing to be repeated can be a vector with multiple elements. rep(c(1,2,3), 10) ## [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 So far we have used positional arguments, where R determines which argument is which by the order in which they are given. We can also give arguments by name. For example, the above is equivalent to rep(c(1,2,3), times=10) ## [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 rep(x=c(1,2,3), 10) ## [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 rep(times=10, x=c(1,2,3)) ## [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 Arguments can have default values, and a function may have many different possible arguments that make it do obscure things. For example, rep can also take an argument each=. It’s typical for a function to be invoked with some number of positional arguments, which are always given, plus some less commonly used arguments, typically given by name. rep(c(1,2,3), each=3) ## [1] 1 1 1 2 2 2 3 3 3 rep(c(1,2,3), each=3, times=5) ## [1] 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 ## [36] 3 1 1 1 2 2 2 3 3 3 Challenge: using functions Use sum to sum from 1 to 10,000. Look at the documentation for the seq function. What does seq do? Give an example of using seq with either the by or length.out argument. "],
["data-frames.html", "2 Data frames 2.1 Setting up 2.2 Loading data 2.3 Exploring 2.4 Indexing data frames 2.5 Columns are vectors 2.6 Logical indexing 2.7 Factors 2.8 Sorting 2.9 Joining data frames 2.10 Further reading", " 2 Data frames Data frame is R’s name for tabular data. We generally want each row in a data frame to represent a unit of observation, and each column to contain a different type of information about the units of observation. Tabular data in this form is called “tidy data”. Today we will be using a collection of modern packages collectively known as the Tidyverse. R and its predecessor S have a history dating back to 1976. The Tidyverse fixes some dubious design decisions baked into “base R”, including having its own slightly improved form of data frame, which is called a tibble. Sticking to the Tidyverse where possible is generally safer, Tidyverse packages are more willing to generate errors rather than ignore problems. 2.1 Setting up Our first step is to download the files we need and to install the Tidyverse. This is the one step where we ask you to copy and paste some code: # Download files for this workshop download.file( &quot;https://drive.google.com/uc?export=download&amp;id=1ORiglWFrxOoQ1-G-1D6-UYGUM9uePd8B&quot;, destfile=&quot;R-intro-data.zip&quot;) unzip(&quot;R-intro-data.zip&quot;) # Install Tidyverse install.packages(&quot;tidyverse&quot;) If using RStudio Cloud, you might need to switch to R version 3.5.3 to successfully install Tidyverse. Use the drop-down in the top right corner of the page. People also sometimes have problems installing all the packages in Tidyverse on Windows machines. If you run into problems you may have more success installing individual packages. install.packages(c(&quot;dplyr&quot;,&quot;readr&quot;,&quot;tidyr&quot;,&quot;ggplot2&quot;)) We need to load the tidyverse package in order to use it. library(tidyverse) # OR library(dplyr) library(readr) library(tidyr) library(ggplot2) The tidyverse package loads various other packages, setting up a modern R environment. In this section we will be using functions from the dplyr, readr and tidyr packages. R is a language with mini-languages within it that solve specific problem domains. dplyr is such a mini-language, a set of “verbs” (functions) that work well together. dplyr, with the help of tidyr for some more complex operations, provides a way to perform most manipulations on a data frame that you might need. 2.2 Loading data We will use the read_tsv function from readr to load a data set. (See also read.csv in base R.) TSV stands for Tab Separated Values, and is a text format used to store tabular data. The first few lines of the file we are loading are shown below. Conventionally the first line contains column headings. th_sampleid disease age_at_dx TH34_1150_S02 Ewing sarcoma 16 TH34_1162_S01 Ewing sarcoma 15 TH34_1163_S01 embryonal rhabdomyosarcoma 18 TH34_1179_S01 colon adenocarcinoma 24 sample_metadata &lt;- read_tsv(&quot;selected_metadata.tsv&quot;) ## Parsed with column specification: ## cols( ## sample = col_character(), ## disease = col_character(), ## age_at_dx = col_double(), ## pedaya = col_character(), ## gender = col_character(), ## site_id = col_character() ## ) read_tsv has guessed the type of data each column holds: &lt;chr&gt; - character strings &lt;dbl&gt; - numerical values. Technically these are “doubles”, which is a way of storing numbers with 15 digits precision. We will also encounter: &lt;lgl&gt; - logical values, TRUE or FALSE. &lt;int&gt; - integers, a fancy name for whole numbers. &lt;fct&gt; - factors, categorical data. We will get to this shortly. You can also see this data frame referring to itself as “a tibble”. This is the Tidyverse’s improved form of data frame. Tibbles present themselves more conveniently than base R data frames. Base R data frames don’t show the type of each column, and output every row when you try to view them. Tip A data frame can also be created from vectors, with the tibble function. (See also data.frame in base R.) For example: tibble(foo=c(10,20,30), bar=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) ## # A tibble: 3 x 2 ## foo bar ## &lt;dbl&gt; &lt;chr&gt; ## 1 10 a ## 2 20 b ## 3 30 c The argument names become column names in the data frame. Tip The path to the file on our server is &quot;selected_metadata.tsv&quot;. This says the file &quot;selected_metadata.tsv&quot; is in your working directory. Sometimes a file is in a subdirectory, in which case the file and directory names are separated by /. Your working directory is shown at the top of the console pane. The path needed might be different on your own computer, depending where you downloaded the file. One way to work out the correct path is to find the file in the file browser pane. 2.3 Exploring The View function gives us a spreadsheet-like view of the data frame. View(sample_metadata) print with the n argument can be used to show more than the first 10 rows on the console. print(sample_metadata, n=200) We can extract details of the data frame with further functions: nrow(sample_metadata) ## [1] 134 ncol(sample_metadata) ## [1] 6 colnames(sample_metadata) ## [1] &quot;sample&quot; &quot;disease&quot; &quot;age_at_dx&quot; &quot;pedaya&quot; &quot;gender&quot; &quot;site_id&quot; summary(sample_metadata) ## sample disease age_at_dx pedaya ## Length:134 Length:134 Min. : 0.200 Length:134 ## Class :character Class :character 1st Qu.: 4.675 Class :character ## Mode :character Mode :character Median :11.615 Mode :character ## Mean :13.061 ## 3rd Qu.:16.000 ## Max. :76.000 ## NA&#39;s :20 ## gender site_id ## Length:134 Length:134 ## Class :character Class :character ## Mode :character Mode :character ## ## ## ## 2.4 Indexing data frames Data frames can be subset using [row,column] syntax. sample_metadata[4,2] ## # A tibble: 1 x 1 ## disease ## &lt;chr&gt; ## 1 hepatoblastoma Note that while this is a single value, it is still wrapped in a data frame. (This is a behaviour specific to Tidyverse data frames.) More on this in a moment. Columns can be given by name. sample_metadata[4,&quot;disease&quot;] ## # A tibble: 1 x 1 ## disease ## &lt;chr&gt; ## 1 hepatoblastoma The column or row may be omitted, thereby retrieving the entire row or column. sample_metadata[4,] ## # A tibble: 1 x 6 ## sample disease age_at_dx pedaya gender site_id ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 TH03_0104_S… hepatoblasto… 0.33 Yes, age &lt; 30 ye… not repor… TH03 sample_metadata[,&quot;disease&quot;] ## # A tibble: 134 x 1 ## disease ## &lt;chr&gt; ## 1 acute leukemia of ambiguous lineage ## 2 acute leukemia of ambiguous lineage ## 3 spindle cell/sclerosing rhabdomyosarcoma ## 4 hepatoblastoma ## 5 spindle cell/sclerosing rhabdomyosarcoma ## 6 Ewing sarcoma ## 7 hepatoblastoma ## 8 acute lymphoblastic leukemia ## 9 synovial sarcoma ## 10 synovial sarcoma ## # … with 124 more rows Multiple rows or columns may be retrieved using a vector. rows_wanted &lt;- c(1,3,5) sample_metadata[rows_wanted,] ## # A tibble: 3 x 6 ## sample disease age_at_dx pedaya gender site_id ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 TH03_0010… acute leukemia of ambi… NA Yes, age &lt;… female TH03 ## 2 TH03_0103… spindle cell/sclerosin… 8 Yes, age &lt;… not rep… &lt;NA&gt; ## 3 TH03_0105… spindle cell/sclerosin… 17 Yes, age &lt;… not rep… TH03 Vector indexing can also be written on a single line. sample_metadata[c(1,3,5),] ## # A tibble: 3 x 6 ## sample disease age_at_dx pedaya gender site_id ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 TH03_0010… acute leukemia of ambi… NA Yes, age &lt;… female TH03 ## 2 TH03_0103… spindle cell/sclerosin… 8 Yes, age &lt;… not rep… &lt;NA&gt; ## 3 TH03_0105… spindle cell/sclerosin… 17 Yes, age &lt;… not rep… TH03 sample_metadata[1:7,] ## # A tibble: 7 x 6 ## sample disease age_at_dx pedaya gender site_id ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 TH03_0010… acute leukemia of ambi… NA Yes, age &lt;… female TH03 ## 2 TH03_0010… acute leukemia of ambi… 11 Yes, age &lt;… female TH03 ## 3 TH03_0103… spindle cell/sclerosin… 8 Yes, age &lt;… not rep… &lt;NA&gt; ## 4 TH03_0104… hepatoblastoma 0.33 Yes, age &lt;… not rep… TH03 ## 5 TH03_0105… spindle cell/sclerosin… 17 Yes, age &lt;… not rep… TH03 ## 6 TH03_0106… Ewing sarcoma 15 Yes, age &lt;… not rep… TH03 ## 7 TH03_0107… hepatoblastoma 1 Yes, age &lt;… not rep… TH03 2.5 Columns are vectors Ok, so how do we actually get data out of a data frame? Under the hood, a data frame is a list of column vectors. We can use $ to retrieve columns. Occasionally it is also useful to use [[ ]] to retrieve columns, for example if the column name we want is stored in a variable. head( sample_metadata$disease ) ## [1] &quot;acute leukemia of ambiguous lineage&quot; ## [2] &quot;acute leukemia of ambiguous lineage&quot; ## [3] &quot;spindle cell/sclerosing rhabdomyosarcoma&quot; ## [4] &quot;hepatoblastoma&quot; ## [5] &quot;spindle cell/sclerosing rhabdomyosarcoma&quot; ## [6] &quot;Ewing sarcoma&quot; head( sample_metadata[[&quot;disease&quot;]] ) ## [1] &quot;acute leukemia of ambiguous lineage&quot; ## [2] &quot;acute leukemia of ambiguous lineage&quot; ## [3] &quot;spindle cell/sclerosing rhabdomyosarcoma&quot; ## [4] &quot;hepatoblastoma&quot; ## [5] &quot;spindle cell/sclerosing rhabdomyosarcoma&quot; ## [6] &quot;Ewing sarcoma&quot; To get the “disease” value of the 4th row as above, but unwrapped, we can use: sample_metadata$disease[4] ## [1] &quot;hepatoblastoma&quot; 2.6 Logical indexing A method of indexing that we haven’t discussed yet is logical indexing. Instead of specifying the row number or numbers that we want, we can give a logical vector which is TRUE for the rows we want and FALSE otherwise. This can also be used with vectors. We will first do this in a slightly verbose way in order to understand it, then learn a more concise way to do this using the dplyr package. is_ewing_sarcoma &lt;- sample_metadata$disease == &quot;Ewing sarcoma&quot; head(is_ewing_sarcoma) ## [1] FALSE FALSE FALSE FALSE FALSE TRUE sum(is_ewing_sarcoma) ## [1] 7 sum treats TRUE as 1 and FALSE as 0, so it tells us the number of TRUE elements in the vector. We can use this logical vector to get the glioma samples from sample_metadata: sample_metadata[is_ewing_sarcoma,] ## # A tibble: 7 x 6 ## sample disease age_at_dx pedaya gender site_id ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 TH03_0106_S… Ewing sarcoma 15 Yes, age &lt; 30 y… not report… TH03 ## 2 TH34_1150_S… Ewing sarcoma 16 Yes, age &lt; 30 y… male &lt;NA&gt; ## 3 TH34_1150_S… Ewing sarcoma 16 Yes, age &lt; 30 y… male &lt;NA&gt; ## 4 TH34_1162_S… Ewing sarcoma 15 Yes, age &lt; 30 y… female &lt;NA&gt; ## 5 TH34_1240_S… Ewing sarcoma 16 Yes, age &lt; 30 y… male TH34 ## 6 TH03_0014_S… Ewing sarcoma 4 Yes, age &lt; 30 y… male TH03 ## 7 TH03_0157_S… Ewing sarcoma 60 No not report… TH03 Comparison operators available are: x == y – “equal to” x != y – “not equal to” x &lt; y – “less than” x &gt; y – “greater than” x &lt;= y – “less than or equal to” x &gt;= y – “greater than or equal to” More complicated conditions can be constructed using logical operators: a &amp; b – “and”, TRUE only if both a and b are TRUE. a | b – “or”, TRUE if either a or b or both are TRUE. ! a – “not” , TRUE if a is FALSE, and FALSE if a is TRUE. The age_at_dx column of sample_metadata tells the age at which the person was diagnosed. We could see which gliomas occured in people over 65 with: ewing_sarcoma_in_male &lt;- is_ewing_sarcoma &amp; sample_metadata$gender == &quot;male&quot; sample_metadata[ewing_sarcoma_in_male,] ## # A tibble: 4 x 6 ## sample disease age_at_dx pedaya gender site_id ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 TH34_1150_S01 Ewing sarcoma 16 Yes, age &lt; 30 years male &lt;NA&gt; ## 2 TH34_1150_S02 Ewing sarcoma 16 Yes, age &lt; 30 years male &lt;NA&gt; ## 3 TH34_1240_S01 Ewing sarcoma 16 Yes, age &lt; 30 years male TH34 ## 4 TH03_0014_S01 Ewing sarcoma 4 Yes, age &lt; 30 years male TH03 ewing_sarcoma_in_male seems like it should be kept within our sample_metadata data frame for future use. We can add it as a new column of the data frame with: sample_metadata$ewing_sarcoma_in_male &lt;- ewing_sarcoma_in_male sample_metadata ## # A tibble: 134 x 7 ## sample disease age_at_dx pedaya gender site_id ewing_sarcoma_i… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 TH03_0… acute leuke… NA Yes, ag… female TH03 FALSE ## 2 TH03_0… acute leuke… 11 Yes, ag… female TH03 FALSE ## 3 TH03_0… spindle cel… 8 Yes, ag… not re… &lt;NA&gt; FALSE ## 4 TH03_0… hepatoblast… 0.33 Yes, ag… not re… TH03 FALSE ## 5 TH03_0… spindle cel… 17 Yes, ag… not re… TH03 FALSE ## 6 TH03_0… Ewing sarco… 15 Yes, ag… not re… TH03 FALSE ## 7 TH03_0… hepatoblast… 1 Yes, ag… not re… TH03 FALSE ## 8 TH03_0… acute lymph… 0.2 Yes, ag… male TH03 FALSE ## 9 TH03_0… synovial sa… NA Yes, ag… male TH03 FALSE ## 10 TH03_0… synovial sa… 17 Yes, ag… male TH03 FALSE ## # … with 124 more rows Challenge: logical indexing Which samples are gliomas? Which samples are in neither ewing sarcoma nor from males? How many samples are from people over 65? 2.6.1 A dplyr shorthand The above method is a little laborious. We have to keep mentioning the name of the data frame, and there is a lot of punctuation to keep track of. dplyr provides a slightly magical function called filter which lets us write more concisely. For example: filter(sample_metadata, sample_metadata$gender == &quot;male&quot; &amp; disease == &quot;Ewing sarcoma&quot;) ## # A tibble: 4 x 7 ## sample disease age_at_dx pedaya gender site_id ewing_sarcoma_in… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 TH34_115… Ewing sa… 16 Yes, age … male &lt;NA&gt; TRUE ## 2 TH34_115… Ewing sa… 16 Yes, age … male &lt;NA&gt; TRUE ## 3 TH34_124… Ewing sa… 16 Yes, age … male TH34 TRUE ## 4 TH03_001… Ewing sa… 4 Yes, age … male TH03 TRUE In the second argument, we are able to refer to columns of the data frame as though they were variables. The code is beautiful, but also opaque. It’s important to understand that under the hood we are creating and combining logical vectors. 2.7 Factors The count function from dplyr can help us understand the contents of some of the columns in sample_metadata. count is also magical, we can refer to columns of the data frame directly in the arguments to count. count(sample_metadata, pedaya) ## # A tibble: 2 x 2 ## pedaya n ## &lt;chr&gt; &lt;int&gt; ## 1 No 8 ## 2 Yes, age &lt; 30 years 126 count(sample_metadata, ewing_sarcoma_in_male) ## # A tibble: 2 x 2 ## ewing_sarcoma_in_male n ## &lt;lgl&gt; &lt;int&gt; ## 1 FALSE 130 ## 2 TRUE 4 Maybe you want the different categories in pedaya to be in a different order, with “Yes” coming first. This comes up quite often, for example when sorting or plotting categorical data. R’s solution is a further type of vector called a factor (think a factor of an experimental design). A factor holds categorical data, and has an associated ordered set of levels. It is otherwise quite similar to a character vector. Any sort of vector can be converted to a factor using the factor function. This function defaults to placing the levels in alphabetical order, but takes a levels argument that can override this. head( factor(sample_metadata$pedaya, levels=c(&quot;Yes, age &lt; 30 years&quot;,&quot;No&quot;)) ) ## [1] Yes, age &lt; 30 years Yes, age &lt; 30 years Yes, age &lt; 30 years ## [4] Yes, age &lt; 30 years Yes, age &lt; 30 years Yes, age &lt; 30 years ## Levels: Yes, age &lt; 30 years No We should modify the pedaya column of the sample_metadata table in order to use this: sample_metadata$pedaya &lt;- factor(sample_metadata$pedaya, c(&quot;Yes, age &lt; 30 years&quot;,&quot;No&quot;)) count now produces the desired order of output: count(sample_metadata, pedaya) ## # A tibble: 2 x 2 ## pedaya n ## &lt;fct&gt; &lt;int&gt; ## 1 Yes, age &lt; 30 years 126 ## 2 No 8 We can count two categorical columns at once. count(sample_metadata, pedaya, ewing_sarcoma_in_male) ## # A tibble: 3 x 3 ## pedaya ewing_sarcoma_in_male n ## &lt;fct&gt; &lt;lgl&gt; &lt;int&gt; ## 1 Yes, age &lt; 30 years FALSE 122 ## 2 Yes, age &lt; 30 years TRUE 4 ## 3 No FALSE 8 Challenge: counting Investigate how many acute myeloid leukemia samples come from adult or pediatric individuals using count 2.8 Sorting Data frames can be sorted using the arrange function in dplyr. arrange(sample_metadata, age_at_dx) ## # A tibble: 134 x 7 ## sample disease age_at_dx pedaya gender site_id ewing_sarcoma_i… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 TH03_00… acute lymp… 0.2 Yes, ag… male TH03 FALSE ## 2 TH03_01… hepatoblas… 0.33 Yes, ag… not re… TH03 FALSE ## 3 TARGET-… acute myel… 0.4 Yes, ag… female TARGET FALSE ## 4 TARGET-… acute myel… 0.44 Yes, ag… male TARGET FALSE ## 5 TARGET-… acute myel… 0.72 Yes, ag… male TARGET FALSE ## 6 TH34_13… juvenile m… 0.75 Yes, ag… female &lt;NA&gt; FALSE ## 7 TH03_01… glioma 0.9 Yes, ag… not re… TH03 FALSE ## 8 TH34_13… myoepithel… 0.96 Yes, ag… male TH34 FALSE ## 9 TH03_01… hepatoblas… 1 Yes, ag… not re… TH03 FALSE ## 10 TH38_14… sarcoma 1.33 Yes, ag… male TH38 FALSE ## # … with 124 more rows Numeric columns are sorted in numeric order. Character columns will be sorted in alphabetical order. Factor columns are sorted in order of their levels. The desc helper function can be used to sort in descending order. arrange(sample_metadata, desc(disease)) ## # A tibble: 134 x 7 ## sample disease age_at_dx pedaya gender site_id ewing_sarcoma_i… ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 TH03_00… wilms tumor 18 Yes, ag… male TH03 FALSE ## 2 TH03_00… wilms tumor 18 Yes, ag… male TH03 FALSE ## 3 TH03_01… wilms tumor 6 Yes, ag… male TH03 FALSE ## 4 TH34_14… undifferent… 16 Yes, ag… female TH34 FALSE ## 5 TH03_01… undifferent… 9 Yes, ag… male TH03 FALSE ## 6 TH03_00… undifferent… NA Yes, ag… not r… TH03 FALSE ## 7 TH03_00… undifferent… 17 Yes, ag… not r… TH03 FALSE ## 8 TH03_00… undifferent… 17 Yes, ag… not r… TH03 FALSE ## 9 TH03_00… undifferent… 12 Yes, ag… male TH03 FALSE ## 10 TH03_00… undifferent… 12 Yes, ag… male TH03 FALSE ## # … with 124 more rows 2.9 Joining data frames Let’s move on to a larger data set. These are some gene expression values. expression_values &lt;- read_tsv(&quot;one_gene_expression.tsv&quot;) Quiz What is the unit of observation in this new data frame? It would be useful to have general information about samples from sample_metadata available as columns when we use this data frame. expression_values and sample_metadata share a column called sample which can be used to match rows from one to the other. expression_by_disease &lt;- left_join(expression_values, sample_metadata, by=c(&quot;sample&quot;)) expression_by_disease ## # A tibble: 134 x 9 ## Gene sample expression disease age_at_dx pedaya gender site_id ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt; ## 1 ABL1 TCGA-… 4.91 acute … 61 No female &lt;NA&gt; ## 2 ABL1 THR24… 4.56 acute … NA Yes, … female THR24 ## 3 ABL1 TARGE… 4.48 acute … NA Yes, … female TARGET ## 4 ABL1 TARGE… 3.72 acute … 4.6 Yes, … female TARGET ## 5 ABL1 TARGE… 2.94 acute … 0.72 Yes, … male TARGET ## 6 ABL1 THR24… 4.75 acute … 4.9 Yes, … female THR24 ## 7 ABL1 TCGA-… 5.55 acute … 21 Yes, … female TCGA ## 8 ABL1 TCGA-… 5.25 acute … 76 No female TCGA ## 9 ABL1 TCGA-… 4.94 acute … NA No female TCGA ## 10 ABL1 TARGE… 4.14 acute … 7.82 Yes, … female TARGET ## # … with 124 more rows, and 1 more variable: ewing_sarcoma_in_male &lt;lgl&gt; The “left” in “left join” refers to how rows that can’t be paired up are handled. left_join keeps all rows from the first data frame but not the second. This is a good default when the intent is to attaching some extra information to a data frame. inner_join discard all rows that can’t be paired up. full_join keeps all rows from both data frames. 2.10 Further reading We’ve covered the fundamentals of dplyr and data frames, but there is much more to learn. Notably, we haven’t covered the use of the pipe %&gt;% to chain dplyr verbs together. The “R for Data Science” book is an excellent source to learn more. The Monash Data Fluency “Programming and Tidy data analysis in R” course also covers this. "],
["plotting-with-ggplot2.html", "3 Plotting with ggplot2 3.1 Elements of a ggplot 3.2 Further geoms 3.3 Highlighting subsets 3.4 Fine-tuning a plot 3.5 Faceting 3.6 Saving ggplots", " 3 Plotting with ggplot2 We already saw some of R’s built in plotting facilities with the function plot. A more recent and much more powerful plotting library is ggplot2. ggplot2 is another mini-language within R, a language for creating plots. It implements ideas from a book called “The Grammar of Graphics”. The syntax can be a little strange, but there are plenty of examples in the online documentation. ggplot2 is part of the Tidyverse, so loadinging the tidyverse package will load ggplot2. library(tidyverse) We continue with the expression dataset, which we loaded with: sample_metadata &lt;- read_tsv(&quot;selected_metadata.tsv&quot;) expression_values &lt;- read_tsv(&quot;one_gene_expression.tsv&quot;) expression_by_disease &lt;- left_join(expression_values, sample_metadata, by=c(&quot;sample&quot;)) 3.1 Elements of a ggplot Producing a plot with ggplot2, we must give three things: A data frame containing our data. How the columns of the data frame can be translated into positions, colors, sizes, and shapes of graphical elements (“aesthetics”). The actual graphical elements to display (“geometric objects”). Let’s make our first ggplot. ggplot(expression_by_disease, aes(x=age_at_dx, y=expression)) + geom_point() The call to ggplot and aes sets up the basics of how we are going to represent the various columns of the data frame. aes defines the “aesthetics”, which is how columns of the data frame map to graphical attributes such as x and y position, color, size, etc. aes is another example of magic “non-standard evaluation”, arguments to aes may refer to columns of the data frame directly. We then literally add layers of graphics (“geoms”) to this. Further aesthetics can be used. Any aesthetic can be either numeric or categorical, an appropriate scale will be used. ggplot(expression_by_disease, aes(x=age_at_dx, y=expression, color=Gene, shape = gender)) + geom_point() 3.1.1 Challenge: make a ggplot Create a ggplot of this with: expression as x. age_at_dx as y. pedaya as the shape disease as the color. ggplot(expression_by_disease, aes(x=expression, y=age_at_dx, color = disease, shape = pedaya)) + geom_point() ## Warning: Removed 20 rows containing missing values (geom_point). 3.2 Further geoms A wide variety of geoms are available. Here we show Tukey box-plots. Note again the use of the “group” aesthetic, without this ggplot will just show one big box-plot. ggplot(expression_by_disease, aes(x=gender, y=expression, group=gender)) + geom_boxplot() geom_smooth can be used to show trends. ggplot(expression_by_disease, aes(x=expression, y=age_at_dx)) + geom_point() + geom_smooth(method = &#39;lm&#39;) Aesthetics can be specified globally in ggplot, or as the first argument to individual geoms. Here “color” is used to produce multiple trend lines: ggplot(expression_by_disease, aes(x=expression, y=age_at_dx)) + geom_point() + geom_smooth(aes(color = gender), method = &#39;lm&#39;) 3.3 Highlighting subsets Geoms can be added that use a different data frame, using the data= argument. expression_in_eRMS &lt;- filter(expression_by_disease, disease == &quot;embryonal rhabdomyosarcoma&quot;) ggplot(expression_by_disease, aes(x=expression, y=age_at_dx)) + geom_point() + geom_point(data = expression_in_eRMS, color = &quot;red&quot;, size = 2) Notice also that the second geom_line has some further arguments controlling its appearance. These are not aesthetics, they are not a mapping of data to appearance, but rather a direct specification of the appearance. There isn’t an associated scale or legend as when color was an aesthetic. 3.4 Fine-tuning a plot Adding labs to a ggplot adjusts the labels given to the axes and legends. A plot title can also be specified. ggplot(expression_by_disease, aes(x=expression, y=age_at_dx)) + geom_point() + labs(x=&quot;Gene expression&quot;, y=&quot;Age&quot;, title=&quot;Expression of one gene&quot;) coord_cartesian can be used to set the limits of the x and y axes. Suppose we want our x-axis to start at zero. ggplot(expression_by_disease, aes(x=expression, y=age_at_dx)) + geom_point() + coord_cartesian(xlim=c(0,7)) Type scale_ and press the tab key. You will see functions giving fine-grained controls over various scales (x, y, color, etc). These allow transformations (eg log10), and manually specified breaks (labelled values). Very fine grained control is possible over the appearance of ggplots, see the ggplot2 documentation for details and further examples. 3.4.1 Challenge: refine your ggplot Continuing with the scatter-plot of the expression_by_disease data, add axis labels to your plot. Give your y axis a log scale by adding scale_y_log10(). 3.5 Faceting Faceting lets us quickly produce a collection of small plots. The plots all have the same scales and the eye can easily compare them. ggplot(expression_by_disease, aes(x=expression, y=age_at_dx)) + geom_point() + facet_wrap(~ gender) Note the use of ~, which we’ve not seen before. ~ syntax is used in R to specify dependence on some set of variables, for example when specifying a linear model. Here the information in each plot is dependent on the continent. When I read it in my mind, I say “by” or “against” 3.5.1 Challenge: facet your ggplot Let’s return again to your scatter-plot of the expression_by_disease data Adjust your plot to now show data, with each gender shown in a separate facet, using facet_wrap(~ gender). Advanced: Highlight Ewing sarcoma in your plot. 3.6 Saving ggplots The act of plotting a ggplot is actually triggered when it is printed. In an interactive session we are automatically printing each value we calculate, but if you are using it with a programming construct such as a for loop or function you might need to explcitly print( ) the plot. Ggplots can be saved using ggsave. # Plot created but not shown. p &lt;- ggplot(expression_by_disease, aes(x=expression, y=age_at_dx)) + geom_point() # Only when we try to look at the value p is it shown p # Alternatively, we can explicitly print it print(p) # To save to a file ggsave(&quot;test.png&quot;, p) # This is an alternative method that works with &quot;base R&quot; plots as well: png(&quot;test.png&quot;) print(p) dev.off() 3.6.1 Tip about sizing Figures in papers tend to be quite small. This means text must be proportionately larger than we usually show on screen. Dots should also be proportionately larger, and lines proportionately thicker. The way to achieve this using ggsave is to specify a small width and height, given in inches. To ensure the output also has good resolution, specify a high dots-per-inch, or use a vector-graphics format such as PDF or SVG. ggsave(&quot;test2.png&quot;, p, width=3, height=3, dpi=600) "],
["summarizing-data.html", "4 Summarizing data 4.1 Summary functions 4.2 Missing values 4.3 Grouped summaries 4.4 t-test", " 4 Summarizing data Having loaded and thoroughly explored a data set, we are ready to distill it down to concise conclusions. At its simplest, this involves calculating summary statistics like counts, means, and standard deviations. Beyond this is the fitting of models, and hypothesis testing and confidence interval calculation. R has a huge number of packages devoted to these tasks and this is a large part of its appeal, but is beyond the scope of today. Loading the data as before, if you have not already done so: library(tidyverse) sample_metadata &lt;- read_tsv(&quot;selected_metadata.tsv&quot;) expression_values &lt;- read_tsv(&quot;one_gene_expression.tsv&quot;) expression_by_disease &lt;- left_join(expression_values, sample_metadata, by=c(&quot;sample&quot;)) 4.1 Summary functions R has a variety of functions for summarizing a vector, including: sum, mean, min, max, median, sd. mean( c(1,2,3,4) ) ## [1] 2.5 We can use these on the expression data. expression_in_AML &lt;- filter(expression_by_disease, disease == &quot;acute myeloid leukemia&quot;) sum(expression_in_AML$age_at_dx) ## [1] NA mean(expression_in_AML$age_at_dx) ## [1] NA 4.2 Missing values Why did mean fail? The reason is that life_exp contains missing values (NA). expression_in_AML$age_at_dx ## [1] 61.00000 NA NA 4.60000 0.72000 4.90000 21.00000 ## [8] 76.00000 NA 7.82000 0.40000 0.44000 NA 55.00000 ## [15] 73.00000 12.91667 11.23000 8.46000 18.96000 47.00000 4.00000 ## [22] 4.00000 14.00000 R will not ignore these unless we explicitly tell it to with na.rm=TRUE. mean(expression_in_AML$age_at_dx, na.rm=TRUE) ## [1] 22.39193 NA is a special value. If we try to calculate with NA, the result is NA NA + 1 ## [1] NA is.na can be used to detect NA values, or na.omit can be used to directly remove rows of a data frame containing them. is.na( c(1,2,NA,3) ) ## [1] FALSE FALSE TRUE FALSE cleaned &lt;- filter(expression_in_AML, !is.na(age_at_dx)) mean(cleaned$age_at_dx) ## [1] 22.39193 4.3 Grouped summaries The summarize function in dplyr allows summary functions to be applied to data frames. summarize(expression_by_disease, mean_age_at_dx = mean(age_at_dx, na.rm=TRUE)) ## # A tibble: 1 x 1 ## mean_age_at_dx ## &lt;dbl&gt; ## 1 13.1 So far unremarkable, but summarize comes into its own when the group_by “adjective” is used. summarize( group_by(expression_by_disease, disease), mean_age_at_dx=mean(age_at_dx,na.rm=TRUE)) ## # A tibble: 36 x 2 ## disease mean_age_at_dx ## &lt;chr&gt; &lt;dbl&gt; ## 1 acute leukemia of ambiguous lineage 11 ## 2 acute lymphoblastic leukemia 6.8 ## 3 acute myeloid leukemia 22.4 ## 4 adrenocortical carcinoma 12 ## 5 alveolar rhabdomyosarcoma 17 ## 6 atypical teratoid/rhabdoid tumor 1.4 ## 7 colon adenocarcinoma 24 ## 8 desmoplastic small round cell tumor 18.5 ## 9 embryonal rhabdomyosarcoma 16 ## 10 ependymoma 6.7 ## # … with 26 more rows group_by can be used to group by multiple columns, much like count. We can use this to see how the rest of the world is catching up to OECD nations in terms of life expectancy. result &lt;- summarize( group_by(expression_by_disease, disease, gender), mean_age_at_dx=mean(age_at_dx,na.rm=TRUE)) result ## # A tibble: 52 x 3 ## # Groups: disease [36] ## disease gender mean_age_at_dx ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 acute leukemia of ambiguous lineage female 11 ## 2 acute lymphoblastic leukemia female NaN ## 3 acute lymphoblastic leukemia male 6.8 ## 4 acute myeloid leukemia female 24.7 ## 5 acute myeloid leukemia male 18.4 ## 6 adrenocortical carcinoma not reported 12 ## 7 alveolar rhabdomyosarcoma female 17 ## 8 atypical teratoid/rhabdoid tumor male 1.4 ## 9 colon adenocarcinoma female 24 ## 10 desmoplastic small round cell tumor male 18.5 ## # … with 42 more rows 4.4 t-test We will finish this section by demonstrating a t-test. The main point of this section is to give a flavour of how statistical tests work in R, rather than the details of what a t-test does. does age of diagnosis differ in males and females with AML? expr_male &lt;- filter(expression_in_AML, gender == &quot;male&quot;) expr_female &lt;- filter(expression_in_AML, gender == &quot;female&quot;) t.test(expr_male$age_at_dx, expr_female$age_at_dx) ## ## Welch Two Sample t-test ## ## data: expr_male$age_at_dx and expr_female$age_at_dx ## t = -0.52009, df = 13.552, p-value = 0.6114 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -32.81913 20.04079 ## sample estimates: ## mean of x mean of y ## 18.35667 24.74583 Statistical routines often have many ways to tweak the details of their operation. These are specified by further arguments to the function call, to override the default behaviour. By default, t.test performs an unpaired t-test. If this was a paired data, we could specify paired=TRUE to t.test to perform a paired sample t-test and gain some statistical power. Check this by looking at the help page with ?t.test. When performing a statistical test, it’s good practice to visualize the data to make sure there is nothing funny going on. ggplot(expression_in_AML, aes(x=gender, y=age_at_dx)) + geom_boxplot() ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). ggplot(expression_in_AML, aes(x=gender, y=age_at_dx)) + geom_jitter() ## Warning: Removed 4 rows containing missing values (geom_point). This is a visual confirmation of the t-test result. If there were no difference between the years then points would lie approximately evenly above and below the diagonal line, which is clearly not the case. However the outlier may warrant investigation. "],
["thinking-in-r.html", "5 Thinking in R 5.1 Lists 5.2 Other types not covered here 5.3 Programming", " 5 Thinking in R The result of a t-test is actually a value we can manipulate further. Two functions help us here. class gives the “public face” of a value, and typeof gives its underlying type, the way R thinks of it internally. For example numbers are “numeric” and have some representation in computer memory, either “integer” for whole numbers only, or “double” which can hold fractional numbers (stored in memory in a base-2 version of scientific notation). class(42) ## [1] &quot;numeric&quot; typeof(42) ## [1] &quot;double&quot; Let’s look at the result of a t-test: result &lt;- t.test(expr_male$age_at_dx, expr_female$age_at_dx) class(result) ## [1] &quot;htest&quot; typeof(result) ## [1] &quot;list&quot; names(result) ## [1] &quot;statistic&quot; &quot;parameter&quot; &quot;p.value&quot; &quot;conf.int&quot; &quot;estimate&quot; ## [6] &quot;null.value&quot; &quot;stderr&quot; &quot;alternative&quot; &quot;method&quot; &quot;data.name&quot; result$p.value ## [1] 0.6113911 In R, a t-test is just another function returning just another type of data, so it can also be a building block. The value it returns is a special type of vector called a “list”, but with a public face that presents itself nicely. This is a common pattern in R. Besides printing to the console nicely, this public face may alter the behaviour of generic functions such as plot and summary. Similarly a data frame is a list of vectors that is able to present itself nicely. 5.1 Lists Lists are vectors that can hold anything as elements (even other lists!). It’s possible to create lists with the list function. This becomes especially useful once you get into the programming side of R. For example writing your own function that needs to return multiple values, it could do so in the form of a list. mylist &lt;- list(hello=c(&quot;Hello&quot;,&quot;world&quot;), numbers=c(1,2,3,4)) mylist ## $hello ## [1] &quot;Hello&quot; &quot;world&quot; ## ## $numbers ## [1] 1 2 3 4 class(mylist) ## [1] &quot;list&quot; typeof(mylist) ## [1] &quot;list&quot; names(mylist) ## [1] &quot;hello&quot; &quot;numbers&quot; Accessing lists can be done by name with $ or by position with [[ ]]. mylist$hello ## [1] &quot;Hello&quot; &quot;world&quot; mylist[[2]] ## [1] 1 2 3 4 5.2 Other types not covered here Matrices are another tabular data type. These come up when doing more mathematical tasks in R. They are also commonly used in bioinformatics, for example to represent RNA-Seq count data. A matrix, as compared to a data frame: contains only one type of data, usually numeric (rather than different types in different columns). commonly has rownames as well as colnames. (Base R data frames can have rownames too, but it is easier to have any unique identifier as a normal column instead.) has individual cells as the unit of observation (rather than rows). Matrices can be created using as.matrix from a data frame, matrix from a single vector, or using rbind or cbind with several vectors. You may also encounter “S4 objects”, especially if you use Bioconductor packages. The syntax for using these is different again, and uses @ to access elements. 5.3 Programming Once you have a useful data analysis, you may want to do it again with different data. You may have some task that needs to be done many times over. This is where programming comes in: Writing your own functions. For-loops to do things multiple times. If-statements to make decisions. The “R for Data Science” book is an excellent source to learn more. Monash Data Fluency “Programming and Tidy data analysis in R” course also covers this. "],
["next-steps.html", "6 Next steps 6.1 How to find help 6.2 General strategies", " 6 Next steps 6.1 How to find help The best source for basics is the book R for Data Science To see the documentation for a function, execute the function with a “?” in front of it like this: ?geom_boxplot When you don’t know what command to use, or the documentation doesn’t help, use Google. In web searches, include the words “tidy” or “ggplot” in your search, like “ggplot boxplot”. Unfortunately searching “R” isn’t very specific. Results from stackoverflow.com are usually good discussions among users Web search results from tidyverse.org are good, but they’re usually just the documentation If you find plotting results that don’t use ggplot, I suggest ignoring them for now. It’s hard to learn two different plotting methods. Check out RStudio’s collection of cheat sheets cover newer packages in R. 6.2 General strategies View a few rows of your data frequently. Plot your data frequency. Plot it in different ways. When you find something interesting, try to disprove what you’ve found. This will help strengthen your evidence and understanding of your result. "]
]
